[{"content":"参考视频：尚硅谷Java入门视频教程\nLambda 简介 Java 8 中引入了一个新的操作符 -\u0026gt; ，该操作符称为 箭头操作符 或 Lambda 操作符。 箭头操作符将 Lambda 表达式拆分为两部分：( 参数列表 ) -\u0026gt; { Lambda 体 }\nLambda 语法格式 语法格式一：无参数，无返回值：() -\u0026gt; {}\n1  () -\u0026gt; System.out.println(\u0026#34;hello Lambda!\u0026#34;);   语法格式二：有一个参数，无返回值（若只有一个参数，小括号可以省略不写）： (x) -\u0026gt; {}\n1 2  Consumer\u0026lt;String\u0026gt; consumer = (x) -\u0026gt; System.out.println(x); Consumer\u0026lt;String\u0026gt; consumer = x -\u0026gt; System.out.println(x);   语法格式三：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句\n1 2 3 4  Comparator\u0026lt;Integer\u0026gt; comparator = (x, y) -\u0026gt; {  System.out.println(\u0026#34;函数式接口\u0026#34;);  return Integer.compare(x, y); };   语法格式四：若 Lambda 体中只有一条语句，return 和 大括号都可以省略不写\n1  Comparator\u0026lt;Integer\u0026gt; comparator = (x, y) -\u0026gt; Integer.compare(x, y);   语法格式五：Lambda 表达式的参数列表的数据类型可以省略不写，JVM编译器可以通过上下文推断出数据类型，即“类型推断”\n1 2  (Integer x, Integer y) -\u0026gt; Integer.compare(x, y); (x, y) -\u0026gt; Integer.compare(x, y);   ","permalink":"/posts/tech/java%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"参考视频：尚硅谷Java入门视频教程 Lambda 简介 Java 8 中引入了一个新的操作符 -\u0026gt; ，该操作符称为 箭头操作符 或 Lambda 操作符。 箭头操作符将 Lambda 表达式拆分为两部分：","title":"Java中的Lambda表达式"},{"content":"944. 删列造序 tag: 字符串、排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * 解题思路：按列比较是否是升序的。 */ class Solution {  public int minDeletionSize(String[] strs) {  // 字符串个数  int m = strs.length;  // 字符串长度  int n = strs[0].length();  // 存储结果  int result = 0;  // 遍历字符串  for (int i = 0; i \u0026lt; n; ++i) {  // 按列遍历  // 第一列的第 i 个字符  char pre = strs[0].charAt(i);  for (int j = 1; j \u0026lt; m; ++j) {  // 当前列字符  char curr = strs[j].charAt(i);  // 如果不是升序，跳出循环，result + 1  if (pre \u0026gt; curr) {  ++result;  break;  }  pre = curr;  }  }  return result;  } }   449. 序列化和反序列化二叉搜索树 tag: 序列化、二叉搜索树、后序遍历、栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  /** * 解题思路：二叉搜索树，中序遍历是有序的。还原一颗二叉树需要通过中序遍历数组 + (先序遍历 / 后序遍历) * 序列化：得到先序遍历/后序遍历数组，再转化为字符串 -- 可以递归实现，这里使用栈实现 * 反序列化：将字符串转化为先序遍历/后序遍历数组，根据二叉搜索树的特性（有序），进行还原。 */ public class Codec {   // Encodes a tree to a single string.  public String serialize(TreeNode root) {  List\u0026lt;Integer\u0026gt; list = postOrder(root);  // 将元素列表转换为字符串  String str = list.toString();  // 去掉 []  return str.substring(1, str.length() - 1);  }   // Decodes your encoded data to tree.  public TreeNode deserialize(String data) {  if (data == \u0026#34;\u0026#34;) {  return null;  }  // 分割字符串  String[] vals = data.split(\u0026#34;, \u0026#34;);  // 通过栈存储元素值  Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;();  for (String val : vals) {  // 转化为整数  stack.push(Integer.parseInt(val));  }  // 构造二叉搜索树  return construct(Integer.MIN_VALUE, Integer.MAX_VALUE, stack);  }   // 根据后序数组 和 二叉搜索树的特性，构造二叉搜索树  private TreeNode construct(int lower, int upper, Deque\u0026lt;Integer\u0026gt; stack) {  if (stack.isEmpty() || lower \u0026gt; stack.peek() || upper \u0026lt; stack.peek()) {  return null;  }  int val = stack.pop();  TreeNode root = new TreeNode(val);  // 后序遍历 -- 左 右 中 --\u0026gt; 进栈之后 -- 中 右 左  root.right = construct(val, upper, stack);  root.left = construct(lower, val, stack);  return root;  }   // 后序遍历 -- 使用栈实现  private List\u0026lt;Integer\u0026gt; postOrder(TreeNode root) {  // 存储元素值  List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();  // 栈 -- 保存没有遍历完成的结点  Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;();  // 保存当前遍历结点的前一个结点  TreeNode pre = null;  while (root != null || !stack.isEmpty()) {  // 结点不空，进栈并访问左子树  if (root != null) {  stack.push(root);  root = root.left;  } else {  // 否则，判断是否访问了右子树  root = stack.peek();  // 如果没有右结点 或者 已经访问过右结点  if (root.right == null || root.right == pre) {  list.add(stack.pop().val);  // 当前遍历的结点  pre = root;  // 置下一个访问的结点为空  root = null;  } else {  // 否则，访问右子树  root = root.right;  }  }  }  return list;  } }   1305. 两棵二叉搜索树中的所有元素 tag: 中序遍历、归并、栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  /** * 解题思路：二叉搜索树 -- 中序遍历元素有序。中序遍历得到有序列表，再合并 */ class Solution {  public List\u0026lt;Integer\u0026gt; getAllElements(TreeNode root1, TreeNode root2) {  return merge(inOrder(root1), inOrder(root2));  }   // 合并有序列表  private List\u0026lt;Integer\u0026gt; merge(List\u0026lt;Integer\u0026gt; result1, List\u0026lt;Integer\u0026gt; result2) {  List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  int n1 = result1.size(), n2 = result2.size();  int i = 0, j = 0;  while (i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2) {  if (result1.get(i) \u0026lt;= result2.get(j)) {  result.add(result1.get(i++));  } else {  result.add(result2.get(j++));  }  }  // result.addAll(index, c) -- 使用此方法可以将剩余下标的元素添加到列表中  while (i \u0026lt; n1) {  result.add(result1.get(i++));  }  while (j \u0026lt; n2) {  result.add(result2.get(j++));  }  return result;  }   // 中序遍历  private List\u0026lt;Integer\u0026gt; inOrder(TreeNode root) {   List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();   // 使用栈保存还没有遍历完成的元素  Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;();   while (root != null || !stack.isEmpty()) {  // 当前结点不空，进栈  if (root != null) {  stack.push(root);  // 遍历左子树  root = root.left;  } else {  // 出栈  TreeNode curr = stack.pop();  // 遍历完成的元素进列表  result.add(curr.val);  // 遍历右子树  root = curr.right;  }  }  return result;  } }   942. 增减字符串匹配 tag: 贪心、双指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution {  public int[] diStringMatch(String s) {  /** * 解题思路：遍历字符串，双指针分别头尾遍历 0~n+1，如果是 \u0026#39;I\u0026#39;，头指针 + 1，否则尾指针 - 1。 */  // 字符串长度  int n = s.length();  // 存储结果  int[] result = new int[n + 1];  // 头指针，尾指针  int l = 0, r = n;  for (int i = 0; i \u0026lt; n; ++i) {  // result[i] \u0026lt; result[i + 1]  if (s.charAt(i) == \u0026#39;I\u0026#39;) {  result[i] = l++;  } else {  // result[i] \u0026gt; result[i + 1]  result[i] = r--;  }  }  // 处理最后一个字符  result[n] = s.charAt(n - 1) == \u0026#39;I\u0026#39; ? l : r;  return result;  } }   442. 数组中重复的数据 tag: 重复、数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution {  public List\u0026lt;Integer\u0026gt; findDuplicates(int[] nums) {  /** * 要求：T：O(n)，S：O(1) * 解题思路：遍历数组 nums，如果 nums[nums[i]] 大于 n，说明已经访问过，为重复元素， * 否则 nums[nums[i]] + n。 */  // 元素的个数  int n = nums.length;  List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for (int i = 0; i \u0026lt; n; ++i) {  // 获得元素下标  int j = (nums[i] - 1) % n;  // 如果 nums[nums[i]] 大于 n，说明已经访问过，为重复元素  if (nums[j] \u0026gt; n) {  result.add(j + 1);  }  // nums[nums[i]] + n  nums[j] += n;  }  return result;  } }   933. 最近的请求次数 tag: 队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class RecentCounter {  // 使用队列保存 [t- 3000, t] 的时间  private Queue\u0026lt;Integer\u0026gt; time;   public RecentCounter() {  // 创建队列  time = new ArrayDeque\u0026lt;\u0026gt;();  }   public int ping(int t) {  // 将超出 [t- 3000, t] 范围的时间点出队列  while (!time.isEmpty() \u0026amp;\u0026amp; t - 3000 \u0026gt; time.peek()) {  time.poll();  }  time.offer(t);  return time.size();  } }   1823. 找出游戏的获胜者 tag: 队列、约瑟夫环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution {  public int findTheWinner(int n, int k) {  /** * 解题思路： * 按照游戏规则进行模拟，使用队列，从当前 curr 遍历 k - 1 个数，并添加到队尾，第 k 个数出队。 */  // 队列  Queue\u0026lt;Integer\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;();  // 添加 n 个元素  for (int i = 1; i \u0026lt;= n; ++i) {  queue.offer(i);  }   while (n-- \u0026gt; 1) {  for (int i = 1; i \u0026lt; k; ++i) {  queue.offer(queue.poll());  }  queue.poll();  }  return queue.peek();  } }   937. 重新排列日志文件 tag: 日志、排序、自定义排序规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class Solution {  public String[] reorderLogFiles(String[] logs) {  /** * 解题思路： * 1.先提取出字母日志，通过最后一个字符判断是否是字母日志 * 2.对字母日志数组进行排序 -- 先按照内容，再按照标识符 * 3.按顺序添加数字日志 */  int n = logs.length, j = 0;  String[] newLogs = new String[n]; // 保存排好序的日志  for (int i = 0; i \u0026lt; n; ++i) {  if (Character.isDigit(logs[i].charAt(logs[i].length() - 1))) {  continue;  }  // 添加字母日志  newLogs[j++] = logs[i];  }  // 对字母日志进行排序  Arrays.sort(newLogs, 0, j, (s1, s2) -\u0026gt; {  // 第一个空格的下标  int index1 = s1.indexOf(\u0026#39; \u0026#39;);  int index2 = s2.indexOf(\u0026#39; \u0026#39;);  // 得到日志内容  String s1_content = s1.substring(index1 + 1);  String s2_content = s2.substring(index2 + 1);  // 判断日志内容是否相等  int res = s1_content.compareTo(s2_content);  if (res != 0) {  return res;  }  // 日志内容相等，获取日志标志  String s1_tag = s1.substring(0, index1);  String s2_tag = s2.substring(0, index2);  // 判断日志标志大小  return s1_tag.compareTo(s2_tag);  });  // 将数字日志添加到新的日志数组中  for (int i = 0; i \u0026lt; n; ++i) {  if (Character.isDigit(logs[i].charAt(logs[i].length() - 1))) {  newLogs[j++] = logs[i];  }  }  // 返回结果  return newLogs;  } }   591. 标签验证器 tag: 栈、验证器、标签、困难\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  class Solution {  public boolean isValid(String code) {  // 解题思路：想到了用栈，但感觉条件匹配好复杂，看了一下官方题解，自己敲一下。  int n = code.length(); // 字符串长度  // 栈，存放开始标签的名称  Deque\u0026lt;String\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;();  int i = 0;  // 遍历字符串  while (i \u0026lt; n) {  // 如果是 \u0026#39;\u0026lt;\u0026#39;  if (code.charAt(i) == \u0026#39;\u0026lt;\u0026#39;) {  // 如果该字符是最后一个字符，则只能是 \u0026#39;\u0026gt;\u0026#39;，返回 false  if (i == n - 1) {  return false;  }  // 如果下一个字符是 \u0026#39;/\u0026#39;，说明是结束标签，寻找下一个 \u0026#39;\u0026gt;\u0026#39; 的位置  if (code.charAt(i + 1) == \u0026#39;/\u0026#39;) {  // 返回 \u0026#39;\u0026gt;\u0026#39; 第一次出现的下标的位置  int j = code.indexOf(\u0026#39;\u0026gt;\u0026#39;, i + 2);  // 没有找到，不是合法结束标签  if (j \u0026lt; 0) {  return false;  }  // 获得标签名称 tag_name  String tagName = code.substring(i + 2, j);  // 栈不空，弹出栈顶元素 -- 标签名，匹配是否相同，如果不相同则不是合法标签  if (stack.isEmpty() || !stack.peek().equals(tagName)) {  return false;  }  // 相同，结束当前标签  stack.pop();   i = j + 1; // 继续遍历元素   // 如果栈空，说明是已遍历完所有标签，i 应该为 n  if (stack.isEmpty() \u0026amp;\u0026amp; i != n) {  return false;  }  } else if (code.charAt(i + 1) == \u0026#39;!\u0026#39;) {  // 如果下一个字符是 \u0026#39;！\u0026#39;，说明是 cdata，匹配是否是合法的 cdata -- \u0026lt;![CDATA[CDATA_CONTENT]]\u0026gt;  // 此时栈中没有开始标签，说明不是合法标签  if (stack.isEmpty()) {  return false;  }  // 剩余的字符无法构成一个合法的 \u0026lt;![CDATA[  if (i + 9 \u0026gt;= n) {  return false;  }  String cdata = code.substring(i + 2, i + 9);  if (!\u0026#34;[CDATA[\u0026#34;.equals(cdata)) {  return false;  }  // 寻找结束标志 -- ]]\u0026gt;  int j = code.indexOf(\u0026#34;]]\u0026gt;\u0026#34;, i + 9);  if (j \u0026lt; 0) {  return false;  }  // 继续遍历元素  i = j + 1;  } else {  // 如果不是以上的情况，说明是一个开始标签  int j = code.indexOf(\u0026#39;\u0026gt;\u0026#39;, i + 1);  if (j \u0026lt; 0) {  return false;  }  // 标签名  String tagName = code.substring(i + 1, j);  // 判断标签名是否符合规则  if (tagName.length() \u0026lt; 1 || tagName.length() \u0026gt; 9) {  return false;  }  for (int k = 0; k \u0026lt; tagName.length(); ++k) {  // 判断是否是大写字母  if (!Character.isUpperCase(tagName.charAt(k))) {  return false;  }  }  // 开始标签名进栈  stack.push(tagName);  i = j + 1;  }  } else {  // 说明是 tag_content，判断是否有开始标签  if (stack.isEmpty()) {  return false;  }  ++i;  }   }  // 如果栈空，是合法闭合标签  return stack.isEmpty();  } }   908. 最小差值 I tag: 数组、最小差值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution {  public int smallestRangeI(int[] nums, int k) {  // 解题思路：最小差值： maxVal - minVal + diff \u0026gt;= 0 (-2k \u0026lt;= diff \u0026lt;= 0)  // 遍历数组，记录最大值、最小值  int minVal = Integer.MAX_VALUE, maxVal = Integer.MIN_VALUE;  for (int num : nums) {  minVal = minVal \u0026gt; num ? num : minVal;  maxVal = maxVal \u0026lt; num ? num : maxVal;  }  // 最小差值  return (maxVal - minVal - 2 * k) \u0026lt; 0 ? 0 : (maxVal - minVal - 2 * k);  } } // 官方取最大值，最小值的方式 -- 数组流 int minNum = Arrays.stream(nums).min().getAsInt(); int maxNum = Arrays.stream(nums).max().getAsInt();   427. 建立四叉树 tag: 四叉树、递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 解题思路：如果当前网格的值相同，则是叶子结点；否则，将当前网格划分为四个子网格，继续对这四个子网格进行递归。 class Solution {  public Node construct(int[][] grid) {  return dfs(grid, 0, grid.length - 1, 0, grid[0].length - 1);  }   private Node dfs(int[][] grid, int r0, int r1, int c0, int c1) {  // 判断当前网格的值是否都相同  boolean same = true;  loop: for (int i = r0; i \u0026lt;= r1; ++i) {  for (int j = c0; j \u0026lt;= c1; ++j) {  // 如果不是全部相同，跳出循环  if (grid[r0][c0] != grid[i][j]) {  same = false;  break loop;  }  }  }  // 如果当前网格数值全部相同，为叶子结点  if (same) {  // grid[r0][c0] == 1 -- 官方写法  return new Node(grid[r0][c0] == 1 ? true : false, true);  }   // 划分  Node node = new Node(true, false);  node.topLeft = dfs(grid, r0, (r0 + r1) / 2, c0, (c0 + c1) / 2);  node.topRight = dfs(grid, r0, (r0 + r1) / 2, (c0 + c1) / 2 + 1, c1);  node.bottomLeft = dfs(grid, (r0 + r1) / 2 + 1, r1, c0, (c0 + c1) / 2);  node.bottomRight = dfs(grid, (r0 + r1) / 2 + 1, r1, (c0 + c1) / 2 + 1, c1);  return node;  } }   官方题解2：使用 递归 + 二维前缀和\n905. Sort Array By Parity tag: 双指针、数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 解题思路：使用双指针，分别从头尾进行遍历，头指针遇到偶数跳过，尾指针遇到奇数跳过，否则进行交换两数。 class Solution {  public int[] sortArrayByParity(int[] nums) {  int n = nums.length;  int left = 0, right = n - 1;  while (left \u0026lt; right) {  // 头指针遍历  while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] % 2 == 0)  ++left;  // 尾指针遍历  while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] % 2 == 1)  --right;  // 交换两个数  int temp = nums[left];  nums[left] = nums[right];  nums[right] = temp;  }  return nums;  } }   ","permalink":"/posts/tech/leetcode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","summary":"944. 删列造序 tag: 字符串、排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 解题思路：按列比较是否是升序的。 */ class Solution { public int minDeletionSize(String[] strs) { //","title":"LeetCode 每日一题"},{"content":"这是一篇文章 ","permalink":"/posts/first-blog/","summary":"这是一篇文章","title":"First Blog"},{"content":"","permalink":"/about/","summary":"","title":"🙋🏻‍♂️关于我"}]